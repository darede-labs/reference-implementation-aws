################################################################################
# PHASE-SPECIFIC PROMPTS
# Copy and paste these prompts after the BASE PROMPT for each phase
################################################################################

================================================================================
PHASE 0 — Repo Skeleton + Contracts (estrutura inicial)
================================================================================

[PASTE BASE PROMPT FIRST]

Phase 0: Create the initial repository skeletons and conventions.

Modify only the files needed for this phase. Create new files when required.

Deliverables:
- Define clean repo structure for:
  1) platform-infra
  2) hello-node-app
- Add README.md for each repo explaining purpose, folders, and workflow
- Add a top-level docs/ folder in platform-infra describing the platform concepts:
  - GitOps with ArgoCD (app-of-apps)
  - Crossplane: XRD/Composition/Claim model
  - Backstage: templates generate Claims into Git
- Add placeholder folders with empty/placeholder YAML where needed:
  - gitops/argocd/root-app.yaml (placeholder)
  - crossplane/providers/ (placeholder)
  - crossplane/xrd/ (placeholder)
  - crossplane/compositions/ (placeholder)
  - backstage/templates/ (placeholder)

Definition of Done:
- Repo structure exists and is consistent
- README explains how phases will be implemented
- No actual infra creation yet, only scaffolding

Output:
- Exact paths + full file contents
- How to validate quickly with tree output instructions

================================================================================
PHASE 1 — EKS Bootstrap (Terraform) (plataforma começa aqui)
================================================================================

[PASTE BASE PROMPT FIRST]

Phase 1: EKS bootstrap from scratch using Terraform.

Modify only the files needed for this phase. Create new files when required.

Deliverables (platform-infra repo):
- terraform/eks/ provisioning:
  - VPC (can use terraform-aws-modules/vpc/aws)
  - EKS cluster (terraform-aws-modules/eks/aws)
  - Managed node group (at least 1)
  - IRSA enabled (OIDC provider)
  - Required IAM roles, security groups
- outputs.tf exposing:
  - cluster_name, region, kubeconfig command hints
- README in terraform/eks explaining apply + kubeconfig

Constraints:
- Minimal variables (cidr, region, cluster name, node size/count)
- Secure defaults
- Keep code readable, avoid complex locals

Definition of Done:
- terraform apply creates EKS
- kubectl get nodes works
- OIDC provider exists

How to test must include:
- terraform init/plan/apply
- aws eks update-kubeconfig
- kubectl get nodes

================================================================================
PHASE 2 — ArgoCD App-of-Apps Bootstrap
================================================================================

[PASTE BASE PROMPT FIRST]

Phase 2: Install ArgoCD and implement app-of-apps bootstrap.

Modify only the files needed for this phase. Create new files when required.

Deliverables (platform-infra repo):
- gitops/argocd/
  - install/argocd-helm-values.yaml (or Helm command documented)
  - projects/platform-project.yaml
  - root-app.yaml (points to gitops/apps/)
- gitops/apps/
  - crossplane-app.yaml (placeholder for Phase 3)
  - backstage-app.yaml (placeholder for later)
  - hello-app.yaml (placeholder for Phase 4)
- Root app must manage child apps (app-of-apps)
- Provide "bootstrap steps" that are minimal and reproducible

Constraints:
- Prefer declarative YAML, avoid click-ops
- Use namespaces properly (argocd, crossplane-system, backstage)

Definition of Done:
- ArgoCD installed and healthy
- Root application exists and syncs child apps (even if placeholders)

How to test includes:
- kubectl apply root app
- kubectl port-forward svc/argocd-server
- verify ArgoCD Applications in UI or kubectl get applications

================================================================================
PHASE 3 — Crossplane + AWS Provider + IRSA (sem static keys)
================================================================================

[PASTE BASE PROMPT FIRST]

Phase 3: Install Crossplane + configure AWS Provider with IRSA and validate with a real resource.

Modify only the files needed for this phase. Create new files when required.

Deliverables (platform-infra repo):
- crossplane/providers/
  - crossplane-helm-values.yaml (optional)
  - provider-aws.yaml (provider install)
  - providerconfig-irsa.yaml (ProviderConfig)
  - iam/ (docs + least privilege policy example)
- gitops/apps/crossplane-app.yaml updated to actually install crossplane and provider via ArgoCD

Validation resource:
- Add an example S3 Bucket managed resource (or Claim) applied via GitOps
- Must create and delete cleanly through reconciliation

Constraints:
- No static AWS keys stored in Kubernetes secrets
- Must use IRSA with a dedicated IAM role for Crossplane
- Keep IAM policy minimal for the bucket test (S3 only)

Definition of Done:
- Crossplane pods healthy
- Provider installed Ready=True
- S3 bucket is created in AWS
- Deleting YAML removes bucket

How to test includes:
- kubectl get pods -n crossplane-system
- kubectl get providers
- aws s3 ls | grep bucket-name

================================================================================
PHASE 4 — Hello Node App + ECR Build + GitOps Deploy via ArgoCD
================================================================================

[PASTE BASE PROMPT FIRST]

Phase 4: Implement hello-node-app repository with GitOps deployment.

Modify only the files needed for this phase. Create new files when required.

Deliverables (hello-node-app repo):
- Minimal Node.js hello world server (port 3000)
- Dockerfile + .dockerignore
- Helm chart under helm/hello-node/
  - Deployment, Service, Ingress optional
- GitHub Actions pipeline using OIDC to AWS:
  - build image
  - push to ECR
  - update helm values image tag (commit back) OR document ArgoCD Image Updater approach

Deliverables (platform-infra repo):
- Update gitops/apps/hello-app.yaml to point ArgoCD to hello-node-app repo
- Provide clear GitOps flow

Constraints:
- No static AWS keys in GitHub
- Keep app simple and stable

Definition of Done:
- push code -> pipeline builds/pushes image -> ArgoCD deploys automatically
- curl returns expected response

How to test includes:
- run app locally
- run helm install locally (optional)
- verify in cluster with kubectl get pods + curl service

================================================================================
PHASE 5 — Crossplane EC2 Self-Service (XRD + Composition P/M/G)
================================================================================

[PASTE BASE PROMPT FIRST]

Phase 5: Implement EC2 self-service using Crossplane XRD + Compositions (t-shirt sizes).

Modify only the files needed for this phase. Create new files when required.

Deliverables (platform-infra repo):
- crossplane/xrd/ec2.xrd.yaml:
  - XEC2Instance
  - EC2InstanceClaim (namespaced claim)
- crossplane/compositions/ec2/
  - composition-small.yaml  -> t3a.small
  - composition-medium.yaml -> t3a.medium
  - composition-large.yaml  -> t3a.large
- Disk fixed at 50GB
- Amazon Linux latest AMI:
  - Prefer SSM public parameter resolution approach
  - If not feasible, document safe fallback strategy

Developer input must be minimal:
- vpcId
- subnetId
- size: small|medium|large

Outputs:
- connection secret with instanceId + privateIp

Constraints:
- Minimal inbound security group rules (deny-by-default)
- No 0.0.0.0/0 inbound
- Tagging: owner/team/app

Definition of Done:
- Claim creates EC2 with correct instance type
- Deleting claim deletes instance
- Connection secret created

How to test includes:
- kubectl apply claim yaml
- aws ec2 describe-instances filter by tags/name
- kubectl get secrets with connection details

================================================================================
PHASE 6 — Backstage Template EC2 (gera Claim no Git)
================================================================================

[PASTE BASE PROMPT FIRST]

Phase 6: Backstage self-service template for EC2 P/M/G that generates Crossplane Claims into Git.

Modify only the files needed for this phase. Create new files when required.

Deliverables (platform-infra repo):
- backstage/templates/ec2-pmg/template.yaml
  - asks: name, size(P/M/G), vpcId, subnetId, owner/team
  - generates a file:
    crossplane/claims/ec2/<name>.yaml
- Register template in Backstage catalog
- Document how template creates PR or commit:
  - MVP can be direct commit
  - Preferred: create PR

Constraints:
- Template must not require manual steps to apply infra
- ArgoCD must apply claims automatically from repo path

Definition of Done:
- Running template produces claim YAML in git
- ArgoCD applies it
- EC2 is created via Crossplane

How to test includes:
- run template
- confirm file created
- watch ArgoCD sync + Crossplane reconcile

================================================================================
PHASE 7 — Expandir recursos (RDS/S3/Lambda/Secrets/SSM/ECS/EKS)
================================================================================

Use esse prompt sempre que quiser adicionar um "produto" novo:

[PASTE BASE PROMPT FIRST]

Phase 7: Add a new self-service resource to the platform using Crossplane + t-shirt sizes.

Resource to implement: <REPLACE_ME> (example: RDS PostgreSQL)

Modify only the files needed for this phase. Create new files when required.

Deliverables:
- XRD + Claim for the resource (namespaced)
- Compositions for small/medium/large with clear mapping
- Minimal developer inputs, good defaults
- Outputs via connection secret
- Example claim YAML in crossplane/claims/examples

Constraints:
- Secure-by-default:
  - encryption at rest
  - no public exposure by default
  - least privilege
- Keep it simple and testable
- ArgoCD applies claims from GitOps automatically

Definition of Done:
- Claim creates real AWS resource
- Connection secret generated (endpoint/credentials as applicable)
- Deleting claim deletes resource (unless deletion protection is enabled and documented)

How to test includes:
- kubectl apply claim
- aws cli validation
- kubectl get connection secret

################################################################################
# END OF PHASE PROMPTS
################################################################################
