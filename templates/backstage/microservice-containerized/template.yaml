apiVersion: scaffolder.backstage.io/v1beta3
kind: Template
metadata:
  name: microservice-containerized
  title: New Microservice (Containerized)
  description: Create a containerized microservice with CI/CD, observability, and GitOps
  tags:
    - nodejs
    - containerized
    - recommended
spec:
  owner: platform-team
  type: service

  parameters:
    - title: Application Configuration
      required:
        - name
        - owner
        - stack
      properties:
        name:
          title: Service Name
          type: string
          description: Unique name for your microservice (lowercase, alphanumeric, hyphens only)
          pattern: '^[a-z0-9-]+$'
          ui:autofocus: true
        description:
          title: Description
          type: string
          description: Brief description of what this service does
        owner:
          title: Owner
          type: string
          description: Team or person responsible for this service
          ui:field: OwnerPicker
          ui:options:
            catalogFilter:
              kind: Group
        stack:
          title: Technology Stack
          type: string
          description: Programming language/framework
          enum:
            - nodejs
            - python
            - go
          enumNames:
            - Node.js (Express)
            - Python (FastAPI)
            - Go (Gin)
          default: nodejs

    - title: Infrastructure Requirements
      description: Configure optional infrastructure components (provisioned via Crossplane)
      properties:
        needsDatabase:
          title: Needs Database?
          type: string
          description: Provision a PostgreSQL RDS instance for this service
          enum:
            - "yes"
            - "no"
          enumNames:
            - Yes, provision RDS
            - No database needed
          default: "no"
        databaseSize:
          title: Database Size
          type: string
          description: T-shirt size for RDS instance (only if database is needed)
          enum:
            - P
            - M
            - G
          enumNames:
            - P - Small (db.t3.micro, 20GB)
            - M - Medium (db.t3.small, 50GB)
            - G - Large (db.t3.medium, 100GB)
          default: P
          dependencies:
            needsDatabase:
              oneOf:
                - properties:
                    needsDatabase:
                      enum: ["yes"]
        needsBucket:
          title: Needs S3 Bucket?
          type: string
          description: Provision an S3 bucket for this service
          enum:
            - "yes"
            - "no"
          enumNames:
            - Yes, provision S3 bucket
            - No bucket needed
          default: "no"

    - title: Deployment Configuration
      required:
        - namespace
        - exposure
      properties:
        namespace:
          title: Kubernetes Namespace
          type: string
          description: Where to deploy this service
          enum:
            - default
            - team-alpha
            - team-beta
          default: default
        exposure:
          title: Service Exposure
          type: string
          description: How should this service be exposed?
          enum:
            - internal
            - public
            - cluster-only
          enumNames:
            - Internal (ALB, internal network only)
            - Public (ALB, internet-facing)
            - Cluster-only (no ingress)
          default: cluster-only
        replicas:
          title: Replicas
          type: number
          description: Number of pod replicas
          default: 2
          minimum: 1
          maximum: 10

  steps:
    # =============================================================================
    # STEP 1: Generate Application Code
    # =============================================================================
    - id: fetch-app
      name: Generate Application Code
      action: fetch:template
      input:
        url: ./skeleton/${{ parameters.stack }}
        targetPath: ./app
        values:
          name: ${{ parameters.name }}
          description: ${{ parameters.description }}
          owner: ${{ parameters.owner }}
          stack: ${{ parameters.stack }}
          containerPort: >
            ${{ parameters.stack == 'nodejs' and 3000 or
                parameters.stack == 'python' and 8000 or 8080 }}
          namespace: ${{ parameters.namespace }}
          replicas: ${{ parameters.replicas }}
          awsRegion: ${{ secrets.AWS_REGION }}
          awsAccountId: ${{ secrets.AWS_ACCOUNT_ID }}
          baseDomain: ${{ secrets.BASE_DOMAIN }}
          gitopsRepo: ${{ parameters.name }}-gitops
          gitHubOrg: ${{ secrets.GITHUB_ORG }}

    # =============================================================================
    # STEP 2: Publish Application Repository
    # =============================================================================
    - id: publish-app
      name: Publish Application Repository
      action: publish:github
      input:
        sourcePath: ./app
        repoUrl: github.com?repo=${{ parameters.name }}&owner=${{ secrets.GITHUB_ORG }}
        description: ${{ parameters.description }}
        defaultBranch: main
        repoVisibility: private
        deleteBranchOnMerge: true
        protectDefaultBranch: false

    # =============================================================================
    # STEP 3: Generate GitOps Manifests
    # =============================================================================
    - id: fetch-gitops
      name: Generate GitOps Manifests
      action: fetch:template
      input:
        url: ./gitops-skeleton
        targetPath: ./gitops
        values:
          name: ${{ parameters.name }}
          description: ${{ parameters.description }}
          owner: ${{ parameters.owner }}
          stack: ${{ parameters.stack }}
          containerPort: >
            ${{ parameters.stack == 'nodejs' and 3000 or
                parameters.stack == 'python' and 8000 or 8080 }}
          namespace: ${{ parameters.namespace }}
          replicas: ${{ parameters.replicas }}
          exposure: ${{ parameters.exposure }}
          needsDatabase: ${{ parameters.needsDatabase }}
          databaseSize: ${{ parameters.databaseSize }}
          needsBucket: ${{ parameters.needsBucket }}
          awsRegion: ${{ secrets.AWS_REGION }}
          awsAccountId: ${{ secrets.AWS_ACCOUNT_ID }}
          baseDomain: ${{ secrets.BASE_DOMAIN }}
          certificateArn: ${{ secrets.CERTIFICATE_ARN }}
          gitHubOrg: ${{ secrets.GITHUB_ORG }}
          environment: production

    # =============================================================================
    # STEP 4: Create Crossplane Claims (if needed)
    # =============================================================================
    - id: create-db-claim
      name: Create RDS Database Claim
      if: ${{ parameters.needsDatabase == 'yes' }}
      action: fs:append
      input:
        path: ./gitops/manifests/database-claim.yaml
        content: |
          apiVersion: platform.darede.io/v1alpha1
          kind: RDSInstanceClaim
          metadata:
            name: ${{ parameters.name }}-db
            namespace: ${{ parameters.namespace }}
            labels:
              app.kubernetes.io/name: ${{ parameters.name }}
              app.kubernetes.io/managed-by: backstage
              backstage.io/owner: ${{ parameters.owner }}
          spec:
            size: ${{ parameters.databaseSize }}
            engine: postgres
            databaseName: ${{ parameters.name | replace('-', '_') }}_db
            subnetIds:
              - ${{ secrets.DB_SUBNET_ID_1 }}
              - ${{ secrets.DB_SUBNET_ID_2 }}
            vpcSecurityGroupIds:
              - ${{ secrets.DB_SECURITY_GROUP_ID }}
            writeConnectionSecretToRef:
              name: ${{ parameters.name }}-db-secret

    - id: create-bucket-claim
      name: Create S3 Bucket Claim
      if: ${{ parameters.needsBucket == 'yes' }}
      action: fs:append
      input:
        path: ./gitops/manifests/bucket-claim.yaml
        content: |
          apiVersion: platform.darede.io/v1alpha1
          kind: S3BucketClaim
          metadata:
            name: ${{ parameters.name }}-bucket
            namespace: ${{ parameters.namespace }}
            labels:
              app.kubernetes.io/name: ${{ parameters.name }}
              app.kubernetes.io/managed-by: backstage
              backstage.io/owner: ${{ parameters.owner }}
          spec:
            bucketName: ${{ secrets.AWS_ACCOUNT_ID }}-${{ parameters.name }}-${{ '' | now | date('unix') }}
            publicAccessBlock: true
            versioning: false

    # =============================================================================
    # STEP 5: Publish GitOps Repository
    # =============================================================================
    - id: publish-gitops
      name: Publish GitOps Repository
      action: publish:github
      input:
        sourcePath: ./gitops
        repoUrl: github.com?repo=${{ parameters.name }}-gitops&owner=${{ secrets.GITHUB_ORG }}
        description: GitOps manifests for ${{ parameters.name }}
        defaultBranch: main
        repoVisibility: private
        deleteBranchOnMerge: true
        protectDefaultBranch: false

    # =============================================================================
    # STEP 6: Create ArgoCD Application (in platform GitOps repo)
    # =============================================================================
    - id: create-argocd-app
      name: Create ArgoCD Application
      action: github:repo:push
      input:
        repoUrl: github.com?repo=${{ secrets.PLATFORM_GITOPS_REPO }}&owner=${{ secrets.GITHUB_ORG }}
        branch: add-app-${{ parameters.name }}
        commitMessage: "feat: add ArgoCD application for ${{ parameters.name }}"
        files:
          - path: applications/workloads/${{ parameters.namespace }}/${{ parameters.name }}/application.yaml
            content: |
              apiVersion: argoproj.io/v1alpha1
              kind: Application
              metadata:
                name: ${{ parameters.name }}
                namespace: argocd
                labels:
                  app.kubernetes.io/name: ${{ parameters.name }}
                  app.kubernetes.io/component: backend
                  app.kubernetes.io/part-of: platform-services
                  app.kubernetes.io/managed-by: backstage
                  backstage.io/owner: ${{ parameters.owner }}
                finalizers:
                  - resources-finalizer.argocd.argoproj.io
              spec:
                project: default
                source:
                  repoURL: https://github.com/${{ secrets.GITHUB_ORG }}/${{ parameters.name }}-gitops.git
                  targetRevision: main
                  path: manifests
                destination:
                  server: https://kubernetes.default.svc
                  namespace: ${{ parameters.namespace }}
                syncPolicy:
                  automated:
                    prune: true
                    selfHeal: true
                    allowEmpty: false
                  syncOptions:
                    - CreateNamespace=true
                    - PruneLast=true
                    - RespectIgnoreDifferences=true
                  retry:
                    limit: 5
                    backoff:
                      duration: 5s
                      factor: 2
                      maxDuration: 3m
                ignoreDifferences:
                - group: apps
                  kind: Deployment
                  jsonPointers:
                  - /spec/replicas

    - id: create-pr-argocd
      name: Create Pull Request for ArgoCD Application
      action: github:pull-request:create
      input:
        repoUrl: github.com?repo=${{ secrets.PLATFORM_GITOPS_REPO }}&owner=${{ secrets.GITHUB_ORG }}
        branch: add-app-${{ parameters.name }}
        title: "feat: Add ArgoCD application for ${{ parameters.name }}"
        description: |
          ## New Application: ${{ parameters.name }}

          **Owner:** ${{ parameters.owner }}
          **Stack:** ${{ parameters.stack }}
          **Namespace:** ${{ parameters.namespace }}

          ### Infrastructure
          - Database: ${{ parameters.needsDatabase }}
          - S3 Bucket: ${{ parameters.needsBucket }}
          - Exposure: ${{ parameters.exposure }}

          ### Repositories
          - App: https://github.com/${{ secrets.GITHUB_ORG }}/${{ parameters.name }}
          - GitOps: https://github.com/${{ secrets.GITHUB_ORG }}/${{ parameters.name }}-gitops

          This PR was auto-generated by Backstage.

    # =============================================================================
    # STEP 7: Register in Backstage Catalog
    # =============================================================================
    - id: register
      name: Register Component in Backstage
      action: catalog:register
      input:
        repoContentsUrl: ${{ steps['publish-app'].output.repoContentsUrl }}
        catalogInfoPath: '/catalog-info.yaml'

  output:
    links:
      - title: Application Repository
        url: ${{ steps['publish-app'].output.remoteUrl }}
      - title: GitOps Repository
        url: ${{ steps['publish-gitops'].output.remoteUrl }}
      - title: ArgoCD Application PR
        url: ${{ steps['create-pr-argocd'].output.remoteUrl }}
      - title: View in Backstage
        icon: catalog
        entityRef: ${{ steps['register'].output.entityRef }}
      - title: CI/CD Pipeline
        url: ${{ steps['publish-app'].output.remoteUrl }}/actions
