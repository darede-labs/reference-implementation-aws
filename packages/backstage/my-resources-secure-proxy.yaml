apiVersion: v1
kind: ConfigMap
metadata:
  name: my-resources-secure-proxy
  namespace: backstage
data:
  proxy.py: |
    import os
    import json
    import requests
    from http.server import BaseHTTPRequestHandler, HTTPServer
    from urllib.parse import urlparse
    from http.cookies import SimpleCookie

    FLASK_SERVICE_URL = os.environ.get('FLASK_SERVICE_URL', 'http://my-resources-plugin.backstage.svc.cluster.local')
    BACKSTAGE_BACKEND_URL = os.environ.get('BACKSTAGE_BACKEND_URL', 'http://backstage-backstage.backstage.svc.cluster.local:7007')

    class SecureProxyHandler(BaseHTTPRequestHandler):
        def do_GET(self):
            parsed_path = urlparse(self.path)

            if parsed_path.path == '/health':
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(json.dumps({"status": "ok"}).encode())
                return

            if parsed_path.path == '/my-resources':
                try:
                    # Extract username from Backstage session
                    username = self.get_authenticated_user()

                    if not username:
                        self.send_error(401, 'Unauthorized: Please log in to Backstage')
                        return

                    print(f"INFO: Authenticated user: {username}")

                    # Call Flask service with authenticated user header
                    # SECURITY: User cannot override this - comes from validated session
                    response = requests.get(
                        f'{FLASK_SERVICE_URL}/my-resources',
                        headers={'X-Backstage-User': username},
                        timeout=10
                    )

                    self.send_response(response.status_code)
                    self.send_header('Content-type', 'application/json')
                    self.send_header('Access-Control-Allow-Origin', '*')
                    self.send_header('Access-Control-Allow-Credentials', 'true')
                    self.end_headers()
                    self.wfile.write(response.content)

                except Exception as e:
                    print(f"ERROR: {e}")
                    self.send_error(500, str(e))
                return

            self.send_error(404)

        def get_authenticated_user(self):
            """
            Extract authenticated username from Backstage session cookie.

            In production, this should:
            1. Extract cookie from request
            2. Validate session with Backstage backend
            3. Get user identity from Backstage Identity API

            For now, we use a simpler approach:
            - Try to get user from Authorization header (if set by Backstage)
            - Fall back to query param for testing (will be removed in prod)
            """

            # Try Authorization header (if Backstage sets it)
            auth_header = self.headers.get('Authorization', '')
            if auth_header.startswith('Bearer '):
                # In production, validate this token with Backstage backend
                # For now, extract from X-Forwarded-User if nginx sets it
                pass

            # Try X-Forwarded-User header (if set by ingress auth)
            forwarded_user = self.headers.get('X-Forwarded-User', '').strip()
            if forwarded_user:
                return forwarded_user

            # Get cookie and validate with Backstage
            cookie_header = self.headers.get('Cookie', '')
            if cookie_header:
                try:
                    # Call Backstage Identity API to get authenticated user
                    response = requests.get(
                        f'{BACKSTAGE_BACKEND_URL}/api/auth/v1/userinfo',
                        headers={'Cookie': cookie_header},
                        timeout=5
                    )

                    if response.status_code == 200:
                        user_info = response.json()
                        # Extract username from userEntityRef: "user:default/username"
                        user_entity_ref = user_info.get('userEntityRef', '')
                        if user_entity_ref:
                            username = user_entity_ref.split('/')[-1]
                            return username
                except Exception as e:
                    print(f"WARN: Failed to validate session with Backstage: {e}")

            # For testing only - this will be removed in production
            parsed_path = urlparse(self.path)
            from urllib.parse import parse_qs
            query_params = parse_qs(parsed_path.query)
            test_user = query_params.get('_test_user', [None])[0]
            if test_user:
                print(f"WARN: Using test user parameter (TESTING ONLY): {test_user}")
                return test_user

            return None

    if __name__ == '__main__':
        server = HTTPServer(('0.0.0.0', 8083), SecureProxyHandler)
        print('Secure Proxy started on port 8083...')
        server.serve_forever()
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-resources-secure-proxy
  namespace: backstage
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-resources-secure-proxy
  template:
    metadata:
      labels:
        app: my-resources-secure-proxy
    spec:
      containers:
      - name: proxy
        image: python:3.11-slim
        ports:
        - containerPort: 8083
        env:
        - name: FLASK_SERVICE_URL
          value: "http://my-resources-plugin.backstage.svc.cluster.local"
        - name: BACKSTAGE_BACKEND_URL
          value: "http://backstage-backstage.backstage.svc.cluster.local:7007"
        command:
        - /bin/sh
        - -c
        - "pip install -q requests && python3 -u /app/proxy.py"
        volumeMounts:
        - name: app
          mountPath: /app
      volumes:
      - name: app
        configMap:
          name: my-resources-secure-proxy
---
apiVersion: v1
kind: Service
metadata:
  name: my-resources-secure-proxy
  namespace: backstage
spec:
  selector:
    app: my-resources-secure-proxy
  ports:
  - port: 80
    targetPort: 8083
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-resources-secure-ingress
  namespace: backstage
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /$2
    nginx.ingress.kubernetes.io/cors-allow-origin: "*"
    nginx.ingress.kubernetes.io/cors-allow-methods: "GET, OPTIONS"
    nginx.ingress.kubernetes.io/cors-allow-credentials: "true"
    nginx.ingress.kubernetes.io/enable-cors: "true"
spec:
  ingressClassName: nginx
  rules:
  - host: backstage.timedevops.click
    http:
      paths:
      - path: /api/my-resources(/|$)(.*)
        pathType: ImplementationSpecific
        backend:
          service:
            name: my-resources-secure-proxy
            port:
              number: 80
