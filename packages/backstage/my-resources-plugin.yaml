apiVersion: v1
kind: ConfigMap
metadata:
  name: my-resources-plugin
  namespace: backstage
data:
  server.py: |
    import os
    import json
    import boto3
    import requests
    from http.server import BaseHTTPRequestHandler, HTTPServer
    from urllib.parse import urlparse

    S3_BUCKET = os.environ.get('S3_BUCKET', 'poc-idp-tfstate')
    AWS_REGION = os.environ.get('AWS_REGION', 'us-east-1')
    BACKSTAGE_BACKEND_URL = os.environ.get('BACKSTAGE_BACKEND_URL', 'http://backstage-backstage.backstage.svc.cluster.local:7007')

    s3 = boto3.client('s3', region_name=AWS_REGION)

    class MyResourcesHandler(BaseHTTPRequestHandler):
        def do_GET(self):
            parsed_path = urlparse(self.path)

            if parsed_path.path == '/health':
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(json.dumps({"status": "ok"}).encode())
                return

            if parsed_path.path == '/my-resources':
                try:
                    # SECURITY: Validate user via Backstage auth (cookie → refresh → userinfo)
                    # Query params are IGNORED to prevent user enumeration
                    username = self.get_authenticated_user()

                    if not username:
                        print("ERROR: Authentication failed - no valid Backstage session")
                        self.send_response(401)
                        self.send_header('Content-type', 'application/json')
                        self.end_headers()
                        self.wfile.write(json.dumps({
                            "error": "Unauthorized",
                            "message": "Please log in to Backstage first"
                        }).encode())
                        return

                    print(f"INFO: Authenticated request from user: {username}")

                    # SECURITY: Only return resources owned by the authenticated user
                    resources = self.list_resources(owner_filter=username)

                    self.send_response(200)
                    self.send_header('Content-type', 'application/json')
                    self.send_header('Access-Control-Allow-Origin', '*')
                    self.send_header('Access-Control-Allow-Credentials', 'true')
                    self.end_headers()
                    self.wfile.write(json.dumps(resources).encode())
                except Exception as e:
                    print(f"Error: {e}")
                    self.send_error(500, str(e))
                return

            self.send_error(404)

        def get_authenticated_user(self):
            """
            Authenticate user via Backstage session cookie.
            Flow: Cookie → /api/auth/oidc/refresh → Bearer token → /api/auth/v1/userinfo → username
            """
            cookie = self.headers.get('Cookie', '')
            if not cookie:
                print("DEBUG: No cookie in request")
                return None

            try:
                # Step 1: Call refresh endpoint to get token from session cookie
                print(f"DEBUG: Calling Backstage refresh endpoint...")
                refresh_response = requests.get(
                    f'{BACKSTAGE_BACKEND_URL}/api/auth/oidc/refresh',
                    headers={'Cookie': cookie},
                    params={'optional': '', 'scope': 'openid profile email'},
                    timeout=5
                )

                print(f"DEBUG: Refresh response status: {refresh_response.status_code}")

                if refresh_response.status_code != 200:
                    print(f"DEBUG: Refresh failed: {refresh_response.text[:200]}")
                    return None

                # Extract backstage token from response
                refresh_data = refresh_response.json()
                backstage_identity = refresh_data.get('backstageIdentity', {})
                token = backstage_identity.get('token', '')

                if not token:
                    # Try to get token from different response structure
                    token = refresh_data.get('token', '')

                if not token:
                    print(f"DEBUG: No token in refresh response: {json.dumps(refresh_data)[:300]}")
                    # Fallback: try to extract identity directly from refresh response
                    identity = backstage_identity.get('identity', {})
                    user_entity_ref = identity.get('userEntityRef', '')
                    if user_entity_ref:
                        username = user_entity_ref.split('/')[-1]
                        print(f"DEBUG: Got username from refresh identity: {username}")
                        return username
                    return None

                # Step 2: Call userinfo endpoint with Bearer token
                print(f"DEBUG: Calling userinfo with Bearer token...")
                userinfo_response = requests.get(
                    f'{BACKSTAGE_BACKEND_URL}/api/auth/v1/userinfo',
                    headers={'Authorization': f'Bearer {token}'},
                    timeout=5
                )

                print(f"DEBUG: Userinfo response status: {userinfo_response.status_code}")

                if userinfo_response.status_code != 200:
                    print(f"DEBUG: Userinfo failed: {userinfo_response.text[:200]}")
                    return None

                user_info = userinfo_response.json()
                user_entity_ref = user_info.get('userEntityRef', '')

                if not user_entity_ref:
                    print(f"DEBUG: No userEntityRef in response: {json.dumps(user_info)[:200]}")
                    return None

                # Extract username: "user:default/matheus-andrade" → "matheus-andrade"
                username = user_entity_ref.split('/')[-1]
                print(f"DEBUG: Extracted username: {username}")
                return username

            except Exception as e:
                print(f"ERROR: Authentication failed: {e}")
                return None

        def list_resources(self, owner_filter=None):
            resources = []

            try:
                paginator = s3.get_paginator('list_objects_v2')
                pages = paginator.paginate(Bucket=S3_BUCKET)

                for page in pages:
                    for obj in page.get('Contents', []):
                        key = obj['Key']

                        # Only process terraform.tfstate files
                        if not key.endswith('terraform.tfstate'):
                            continue

                        # Parse: type/owner/name/terraform.tfstate
                        parts = key.split('/')
                        if len(parts) < 4:
                            continue

                        resource_type = parts[0]
                        resource_owner = parts[1]
                        resource_name = parts[2]

                        # Filter by owner if specified
                        if owner_filter and resource_owner != owner_filter:
                            continue

                        # Download and check if state has actual resources
                        try:
                            state_obj = s3.get_object(Bucket=S3_BUCKET, Key=key)
                            state_content = state_obj['Body'].read().decode('utf-8')
                            state_data = json.loads(state_content)

                            # Skip empty states (after terraform destroy)
                            if not state_data.get('resources') or len(state_data.get('resources', [])) == 0:
                                continue
                        except Exception as e:
                            print(f"Error reading state {key}: {e}")
                            continue

                        resources.append({
                            'type': resource_type,
                            'owner': resource_owner,
                            'name': resource_name,
                            'stateKey': f"{resource_type}/{resource_owner}/{resource_name}",
                            'lastModified': obj['LastModified'].isoformat(),
                            'size': obj['Size']
                        })
            except Exception as e:
                print(f"Error listing resources: {e}")
                raise

            return resources

    if __name__ == '__main__':
        server = HTTPServer(('0.0.0.0', 8081), MyResourcesHandler)
        print('My Resources Plugin started on port 8081...')
        server.serve_forever()
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-resources-plugin
  namespace: backstage
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-resources-plugin
  template:
    metadata:
      labels:
        app: my-resources-plugin
    spec:
      serviceAccountName: backstage
      containers:
      - name: plugin
        image: python:3.11-slim
        ports:
        - containerPort: 8081
        env:
        - name: S3_BUCKET
          value: "poc-idp-tfstate"
        - name: AWS_REGION
          value: "us-east-1"
        command:
        - /bin/sh
        - -c
        - "pip install -q boto3 requests && python3 -u /app/server.py"
        volumeMounts:
        - name: app
          mountPath: /app
      volumes:
      - name: app
        configMap:
          name: my-resources-plugin
---
apiVersion: v1
kind: Service
metadata:
  name: my-resources-plugin
  namespace: backstage
spec:
  selector:
    app: my-resources-plugin
  ports:
  - port: 80
    targetPort: 8081
